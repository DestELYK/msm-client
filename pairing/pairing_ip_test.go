package pairing

import (
	"testing"
	"time"

	"msm-client/config"
	"msm-client/utils"
)

func TestIPSubnetMatching(t *testing.T) {
	tests := []struct {
		name     string
		ip1      string
		ip2      string
		expected bool
	}{
		{
			name:     "Same IPv4 address",
			ip1:      "192.168.1.100",
			ip2:      "192.168.1.100",
			expected: true,
		},
		{
			name:     "Same IPv4 subnet",
			ip1:      "192.168.1.100",
			ip2:      "192.168.1.200",
			expected: true,
		},
		{
			name:     "Different IPv4 subnet",
			ip1:      "192.168.1.100",
			ip2:      "192.168.2.100",
			expected: false,
		},
		{
			name:     "IPv4 vs IPv6",
			ip1:      "192.168.1.100",
			ip2:      "::1",
			expected: false,
		},
		{
			name:     "Invalid IP",
			ip1:      "192.168.1.100",
			ip2:      "invalid",
			expected: false,
		},
		{
			name:     "Localhost IPv4",
			ip1:      "127.0.0.1",
			ip2:      "127.0.0.2",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isIPInSameSubnet(tt.ip1, tt.ip2)
			if result != tt.expected {
				t.Errorf("isIPInSameSubnet(%s, %s) = %v, expected %v", tt.ip1, tt.ip2, result, tt.expected)
			}
		})
	}
}

func TestValidatePairingIP(t *testing.T) {
	pm := NewPairingManager()

	tests := []struct {
		name           string
		config         config.ClientConfig
		pairCodeIP     string
		clientIP       string
		expectedResult bool
		expectedReason string
	}{
		{
			name: "Disabled IP validation",
			config: config.ClientConfig{
				DisableIPValidation: true,
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "10.0.0.100",
			expectedResult: true,
			expectedReason: "",
		},
		{
			name: "Strict validation - same IP",
			config: config.ClientConfig{
				StrictIPValidation: true,
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "192.168.1.100",
			expectedResult: true,
			expectedReason: "",
		},
		{
			name: "Strict validation - different IP",
			config: config.ClientConfig{
				StrictIPValidation: true,
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "192.168.1.200",
			expectedResult: false,
			expectedReason: "strict IP validation enabled: code generated by 192.168.1.100, attempt from 192.168.1.200",
		},
		{
			name: "Subnet validation - same subnet",
			config: config.ClientConfig{
				AllowIPSubnetMatch: true,
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "192.168.1.200",
			expectedResult: true,
			expectedReason: "",
		},
		{
			name: "Subnet validation - different subnet",
			config: config.ClientConfig{
				AllowIPSubnetMatch: true,
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "192.168.2.100",
			expectedResult: false,
			expectedReason: "subnet validation failed: code generated by 192.168.1.100, attempt from 192.168.2.100 (different subnets)",
		},
		{
			name:   "Default validation - permissive",
			config: config.ClientConfig{
				// No specific validation flags set
			},
			pairCodeIP:     "192.168.1.100",
			clientIP:       "10.0.0.100",
			expectedResult: true,
			expectedReason: "",
		},
		{
			name: "No pair code IP set",
			config: config.ClientConfig{
				StrictIPValidation: true,
			},
			pairCodeIP:     "",
			clientIP:       "192.168.1.100",
			expectedResult: true,
			expectedReason: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pm.SetConfig(tt.config)
			pm.pairCodeIP = tt.pairCodeIP

			result, reason := pm.validatePairingIP(tt.clientIP)

			if result != tt.expectedResult {
				t.Errorf("validatePairingIP() result = %v, expected %v", result, tt.expectedResult)
			}

			if tt.expectedReason != "" && reason != tt.expectedReason {
				t.Errorf("validatePairingIP() reason = %q, expected %q", reason, tt.expectedReason)
			}
		})
	}
}

func TestConfigurableSecuritySettings(t *testing.T) {
	pm := NewPairingManager()

	// Test default values
	cfg := config.ClientConfig{}
	pm.SetConfig(cfg)

	// Simulate IP violations with default settings (3 violations, 1 hour blacklist)
	ip := "192.168.1.100"

	// Record violations up to the default limit
	for i := 0; i < 3; i++ {
		blacklisted := pm.recordIPViolation(ip)
		if i < 2 && blacklisted {
			t.Errorf("IP should not be blacklisted after %d violations with default limit", i+1)
		}
		if i == 2 && !blacklisted {
			t.Errorf("IP should be blacklisted after %d violations with default limit", i+1)
		}
	}

	// Test custom settings
	cfg.MaxIPViolations = 5
	cfg.IPBlacklistDuration = 30 * time.Minute
	pm.SetConfig(cfg)

	// Clear previous blacklist
	pm.ClearBlacklist()

	ip2 := "192.168.1.101"

	// Record violations up to the new limit
	for i := 0; i < 5; i++ {
		blacklisted := pm.recordIPViolation(ip2)
		if i < 4 && blacklisted {
			t.Errorf("IP should not be blacklisted after %d violations with custom limit of 5", i+1)
		}
		if i == 4 && !blacklisted {
			t.Errorf("IP should be blacklisted after %d violations with custom limit of 5", i+1)
		}
	}

	// Verify blacklist duration is set correctly
	blacklistStatus := pm.GetBlacklistStatus()
	if expiry, exists := blacklistStatus[ip2]; exists {
		expectedExpiry := time.Now().Add(30 * time.Minute)
		// Allow some tolerance for test execution time
		if expectedExpiry.Sub(expiry) > 5*time.Second || expiry.Sub(expectedExpiry) > 5*time.Second {
			t.Errorf("Blacklist expiry time not within expected range. Expected around %v, got %v", expectedExpiry, expiry)
		}
	} else {
		t.Error("IP should be in blacklist after reaching violation limit")
	}
}

func TestConfigurableVerificationCodeSettings(t *testing.T) {
	pm := NewPairingManager()

	// Test with custom verification code settings
	cfg := config.ClientConfig{
		VerificationCodeLength:   8,
		VerificationCodeAttempts: 5,
	}
	pm.SetConfig(cfg)

	// Generate a pairing code and verify it uses the configured length
	pm.codeMutex.Lock()
	codeLength := cfg.GetVerificationCodeLength()
	pm.pairCode = utils.GenerateCode(codeLength)
	pm.expiry = time.Now().Add(1 * time.Minute)
	pm.failCount = 0
	pm.codeMutex.Unlock()

	// Verify the code length matches configuration
	code, _ := pm.GetPairingCode()
	if len(code) != 8 {
		t.Errorf("Expected code length of 8, got %d", len(code))
	}

	// Test validation with custom attempt limit (5 attempts)
	// Wrong attempts should return false but code should remain valid until limit exceeded
	for i := 0; i < 5; i++ {
		// Each wrong attempt should return false (incorrect code)
		result := pm.ValidateCode("wrong")
		if result {
			t.Errorf("Wrong code should return false on attempt %d", i+1)
		}

		// But the code should still be retrievable until we hit the limit
		if i < 4 {
			code, expiry := pm.GetPairingCode()
			if code == "" || expiry.IsZero() {
				t.Errorf("Code should still be available after %d failed attempts (limit is 5)", i+1)
			}
		}
	}

	// After 5 failed attempts, the code should be permanently invalid
	code, expiry := pm.GetPairingCode()
	if code != "" || !expiry.IsZero() {
		t.Error("Code should be permanently invalid after 5 failed attempts")
	}

	// Test with default settings
	pm.ResetPairing()
	cfg = config.ClientConfig{} // Use defaults
	pm.SetConfig(cfg)

	pm.codeMutex.Lock()
	codeLength = cfg.GetVerificationCodeLength() // Should be 6 by default
	pm.pairCode = utils.GenerateCode(codeLength)
	pm.expiry = time.Now().Add(1 * time.Minute)
	pm.failCount = 0
	pm.codeMutex.Unlock()

	code, _ = pm.GetPairingCode()
	if len(code) != 6 {
		t.Errorf("Expected default code length of 6, got %d", len(code))
	}

	// Should allow up to 3 attempts by default
	for i := 0; i < 3; i++ {
		// Each wrong attempt should return false (incorrect code)
		result := pm.ValidateCode("wrong")
		if result {
			t.Errorf("Wrong code should return false on attempt %d", i+1)
		}

		// But the code should still be retrievable until we hit the limit
		if i < 2 {
			code, expiry := pm.GetPairingCode()
			if code == "" || expiry.IsZero() {
				t.Errorf("Code should still be available after %d failed attempts (default limit is 3)", i+1)
			}
		}
	}

	// After 3 failed attempts, the code should be permanently invalid
	code, expiry = pm.GetPairingCode()
	if code != "" || !expiry.IsZero() {
		t.Error("Code should be permanently invalid after 3 failed attempts (default)")
	}
}
